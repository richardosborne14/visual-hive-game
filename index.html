<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Hive: Quest for Series A</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        canvas {
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <script src="https://unpkg.com/kaboom@3000.1.17/dist/kaboom.mjs" type="module"></script>
    
    <script type="module">
        import kaboom from "https://unpkg.com/kaboom@3000.1.17/dist/kaboom.mjs";

        kaboom({
            width: 1000,
            height: 600,
            background: [20, 20, 40],
        });

        // Load sprites
        loadSprite("bogdan", "assets/sprites/bogdan.jpeg");
        loadSprite("petrica", "assets/sprites/petrica.jpeg");
        loadSprite("richard", "assets/sprites/richard.jpeg");
        loadSprite("dishant", "assets/sprites/dishant.jpeg");
        loadSprite("thong", "assets/sprites/thong.jpeg");
        loadSprite("caroline", "assets/sprites/caroline.jpeg");
        loadSprite("kunal", "assets/sprites/kunal.jpeg");
        loadSprite("kateryna", "assets/sprites/kateryna.jpeg");
        loadSprite("maksym", "assets/sprites/maksym.jpeg");
        loadSprite("arianne", "assets/sprites/arianne.jpeg");
        loadSprite("iustina", "assets/sprites/iustina.png");

        scene("main", () => {
            add([
                text("Visual Hive: Quest for Series A", { size: 32 }),
                pos(width() / 2, 40),
                anchor("center"),
                color(255, 215, 0),
            ]);

            add([
                text("Explore ALL team members to secure Series A!", { size: 16 }),
                pos(width() / 2, 80),
                anchor("center"),
                color(200, 200, 200),
            ]);

            add([
                rect(400, 30),
                pos(width() / 2 - 200, 120),
                color(60, 60, 80),
            ]);

            const progressBar = add([
                rect(0, 26),
                pos(width() / 2 - 198, 122),
                color(100, 200, 100),
                { progress: 0 },
            ]);

            const progressText = add([
                text("Series A Progress: 0%", { size: 14 }),
                pos(width() / 2, 135),
                anchor("center"),
                color(255, 255, 255),
            ]);

            const characters = [
                { 
                    name: "Bogdan", role: "CEO", color: [255, 100, 100], pos: [200, 220], emoji: "ðŸ¤", boost: 15,
                    connections: ["Petrica", "Kunal"],
                    profile: {
                        funFact: "Can negotiate a deal while doing yoga poses",
                        superpower: "Turning 'No' into 'Yes' with charm",
                        quote: "Every rejection is just practice for the next acceptance!",
                        hobby: "Collecting vintage startup pitch decks"
                    }
                },
                { 
                    name: "Petrica", role: "COO", color: [75, 75, 150], pos: [450, 220], emoji: "ðŸ›¡ï¸", boost: 10,
                    connections: ["Bogdan", "Kunal", "Iustina", "Dishant"],
                    profile: {
                        funFact: "Once organized a team retreat in 24 hours",
                        superpower: "Making chaos look like a perfectly planned strategy",
                        quote: "Operations is just organized chaos with better documentation",
                        hobby: "Building intricate LEGO cities"
                    }
                },
                { 
                    name: "Richard", role: "CTO", color: [100, 150, 255], pos: [750, 220], emoji: "ðŸ’»", boost: 12,
                    connections: ["Caroline", "Kateryna", "Maksym", "Dishant", "Thong", "Iustina", "Arianne", "Kunal"],
                    profile: {
                        funFact: "Codes in 7 languages but still can't order coffee in French",
                        superpower: "Debugging production at 3 AM like a wizard",
                        quote: "It's not a bug, it's an undocumented feature!",
                        hobby: "Building mechanical keyboards"
                    }
                },
                { 
                    name: "Dishant", role: "Lead Dev", color: [100, 180, 100], pos: [150, 380], emoji: "ðŸ”ï¸", boost: 13,
                    connections: ["Richard", "Petrica", "Iustina", "Arianne"],
                    profile: {
                        funFact: "Climbed mountains on 3 continents while debugging remotely",
                        superpower: "Writing clean code that works on first try",
                        quote: "The best code is like a mountain path - clear and direct",
                        hobby: "Adventure photography"
                    }
                },
                { 
                    name: "Thong", role: "Programmer", color: [150, 255, 100], pos: [350, 380], emoji: "âš¡", boost: 14,
                    connections: ["Richard"],
                    profile: {
                        funFact: "Can solve algorithms while eating pho",
                        superpower: "Making impossible deadlines possible",
                        quote: "Real! (Everything is achievable with enough coffee)",
                        hobby: "Speed coding competitions"
                    }
                },
                { 
                    name: "Caroline", role: "Product", color: [180, 100, 200], pos: [550, 380], emoji: "âœ¨", boost: 11,
                    connections: ["Richard", "Maksym"],
                    profile: {
                        funFact: "User interviews are her favorite form of therapy",
                        superpower: "Turning user complaints into feature gold",
                        quote: "Every user story has a happy ending... eventually",
                        hobby: "UX sketching in coffee shops"
                    }
                },
                { 
                    name: "Kunal", role: "Sales", color: [255, 140, 50], pos: [750, 380], emoji: "ðŸ¥ƒ", boost: 13,
                    connections: ["Bogdan", "Petrica", "Richard"],
                    profile: {
                        funFact: "Closed a deal during a whiskey tasting event",
                        superpower: "Building rapport in under 5 minutes",
                        quote: "Every 'No' is just a 'Yes' waiting for the right moment",
                        hobby: "Whiskey collecting and storytelling"
                    }
                },
                { 
                    name: "Kateryna", role: "DevOps", color: [150, 50, 100], pos: [200, 520], emoji: "ðŸ¦‡", boost: 12,
                    connections: ["Richard", "Maksym"],
                    profile: {
                        funFact: "Deploys code at midnight because she's naturally nocturnal",
                        superpower: "Making servers purr like happy cats",
                        quote: "If it's not automated, it's not worth doing twice",
                        hobby: "Gothic architecture photography"
                    }
                },
                { 
                    name: "Maksym", role: "DevOps", color: [50, 200, 255], pos: [400, 520], emoji: "ðŸ§ ", boost: 10,
                    connections: ["Richard", "Kateryna", "Caroline"],
                    profile: {
                        funFact: "Can predict server failures by reading cloud patterns",
                        superpower: "Infrastructure orchestration that boosts team synergy",
                        quote: "The cloud is just someone else's computer... that I monitor",
                        hobby: "Chess and cloud watching"
                    }
                },
                { 
                    name: "Arianne", role: "Junior Dev", color: [255, 150, 150], pos: [600, 520], emoji: "ðŸŒ±", boost: 8, growth: 0,
                    connections: ["Richard", "Dishant"],
                    profile: {
                        funFact: "Learns a new programming concept every day",
                        superpower: "Growing stronger with each challenge (literally!)",
                        quote: "Today's bug is tomorrow's expertise",
                        hobby: "Contributing to open source projects"
                    }
                },
                { 
                    name: "Iustina", role: "PM", color: [120, 120, 120], pos: [800, 520], emoji: "ðŸ•µï¸", boost: 10,
                    connections: ["Petrica", "Richard", "Dishant"],
                    profile: {
                        funFact: "Can detect scope creep from a mile away",
                        superpower: "Keeping projects on track with mysterious precision",
                        quote: "Every timeline is a challenge accepted",
                        hobby: "Mystery novel reading and escape rooms"
                    }
                },
            ];

            let nextBoosted = false;
            const charObjects = [];
            let currentProfile = null;
            let profileDisplay = null;
            let exploredCount = 0;
            const totalMembers = characters.length;
            let connections = [];
            let connectionTime = 0;
            let activeConnections = new Set();

            const explorationText = add([
                text(`Team Members Explored: 0/${totalMembers}`, { size: 14 }),
                pos(width() / 2, 160),
                anchor("center"),
                color(255, 215, 0),
            ]);

            // Create character lookup map for quick access
            const characterMap = {};
            characters.forEach(char => {
                characterMap[char.name] = char;
            });

            // Function to get connection line color based on characters
            function getConnectionColor(char1, char2) {
                if ((char1.name === "Bogdan" && char2.name === "Petrica") || 
                    (char1.name === "Petrica" && char2.name === "Kunal") ||
                    (char1.name === "Bogdan" && char2.name === "Kunal")) {
                    return [255, 215, 0]; // Golden for leadership triangle
                }
                if (char1.name === "Richard" || char2.name === "Richard") {
                    return [100, 150, 255]; // Blue for Richard's tech connections
                }
                if ((char1.name === "Arianne" && (char2.name === "Richard" || char2.name === "Dishant")) ||
                    (char2.name === "Arianne" && (char1.name === "Richard" || char1.name === "Dishant"))) {
                    return [150, 255, 150]; // Green for mentorship
                }
                if ((char1.name === "Caroline" && char2.name === "Maksym") || 
                    (char1.name === "Maksym" && char2.name === "Caroline")) {
                    return [180, 100, 200]; // Purple for cross-functional
                }
                return [150, 150, 200]; // Default connection color
            }

            // Function to draw connection line using rectangles
            function drawConnection(char1, char2, intensity = 1) {
                const baseColor = getConnectionColor(char1, char2);
                const thickness = 2;
                
                // Calculate line properties
                const dx = char2.pos[0] - char1.pos[0];
                const dy = char2.pos[1] - char1.pos[1];
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Shorten lines to not overlap with circles
                const shortenBy = 45;
                const lineLength = distance - (shortenBy * 2);
                
                if (lineLength <= 0) return null;
                
                const angle = Math.atan2(dy, dx);
                const centerX = (char1.pos[0] + char2.pos[0]) / 2;
                const centerY = (char1.pos[1] + char2.pos[1]) / 2;
                
                // Adjust color based on intensity
                const connectionColor = [
                    Math.floor(baseColor[0] * intensity),
                    Math.floor(baseColor[1] * intensity),
                    Math.floor(baseColor[2] * intensity)
                ];
                
                return add([
                    rect(lineLength, thickness),
                    pos(centerX, centerY),
                    anchor("center"),
                    rotate(angle),
                    color(connectionColor[0], connectionColor[1], connectionColor[2]),
                    z(-1),
                    "connection",
                    { char1: char1.name, char2: char2.name, baseIntensity: intensity }
                ]);
            }

            // Function to show connections for a character
            function showCharacterConnections(characterName, intensity = 1) {
                const char = characterMap[characterName];
                if (!char || !char.connections) return;
                
                char.connections.forEach(connectedName => {
                    const connectionKey = [characterName, connectedName].sort().join('-');
                    if (!activeConnections.has(connectionKey)) {
                        const connectedChar = characterMap[connectedName];
                        if (connectedChar) {
                            const connection = drawConnection(char, connectedChar, intensity);
                            connections.push(connection);
                            activeConnections.add(connectionKey);
                        }
                    }
                });
            }

            // Function to clear all connections
            function clearConnections() {
                connections.forEach(conn => conn.destroy());
                connections = [];
                activeConnections.clear();
            }

            // Function to trigger connection ripple effect
            function triggerConnectionRipple(characterName) {
                clearConnections();
                showCharacterConnections(characterName, 0.9);
                
                // Add secondary connections after a short delay
                wait(0.2, () => {
                    const char = characterMap[characterName];
                    if (char && char.connections) {
                        char.connections.forEach(connectedName => {
                            showCharacterConnections(connectedName, 0.5);
                        });
                    }
                });
                
                // Clear connections after 2 seconds
                wait(2, () => {
                    clearConnections();
                });
            }

            characters.forEach(char => {
                // Add explored property to track if character has been clicked
                char.explored = false;
                const charCircle = add([
                    circle(40),
                    pos(char.pos[0], char.pos[1]),
                    anchor("center"),
                    color(char.color[0], char.color[1], char.color[2]),
                    area(),
                    "character",
                    { cooldown: false, charData: char },
                ]);

                charObjects.push(charCircle);

                // Try to add sprite
                try {
                    add([
                        sprite(char.name.toLowerCase()),
                        pos(char.pos[0], char.pos[1]),
                        anchor("center"),
                        scale(0.25),
                    ]);
                } catch (e) {
                    // Sprite not available, that's OK
                }

                // Emoji removed - sprites are showing now!
                // Uncomment if you want emoji back:
                /*
                add([
                    text(char.emoji, { size: 32 }),
                    pos(char.pos[0], char.pos[1]),
                    anchor("center"),
                ]);
                */

                add([
                    text(char.name, { size: 16 }),
                    pos(char.pos[0], char.pos[1] + 60),
                    anchor("center"),
                ]);

                add([
                    text(char.role, { size: 12 }),
                    pos(char.pos[0], char.pos[1] + 80),
                    anchor("center"),
                    color(180, 180, 180),
                ]);
            });

            function showProfile(char) {
                // Hide existing profile if any
                if (profileDisplay) {
                    hideProfile();
                }

                currentProfile = char;
                const profile = char.profile;
                
                // Create profile background
                const profileBg = add([
                    rect(350, 260),
                    pos(width() / 2 - 175, height() / 2 - 130),
                    color(30, 30, 50),
                    outline(2, [char.color[0], char.color[1], char.color[2]]),
                    z(100),
                ]);

                // Profile header
                const headerText = add([
                    text(`${char.name} - ${char.role}`, { size: 20 }),
                    pos(width() / 2, height() / 2 - 110),
                    anchor("center"),
                    color(char.color[0], char.color[1], char.color[2]),
                    z(101),
                ]);

                // Profile content
                const funFactText = add([
                    text(`Fun Fact: ${profile.funFact}`, { size: 12, width: 320 }),
                    pos(width() / 2 - 160, height() / 2 - 80),
                    color(200, 200, 200),
                    z(101),
                ]);

                const superpowerText = add([
                    text(`Superpower: ${profile.superpower}`, { size: 12, width: 320 }),
                    pos(width() / 2 - 160, height() / 2 - 50),
                    color(255, 215, 0),
                    z(101),
                ]);

                const quoteText = add([
                    text(`"${profile.quote}"`, { size: 12, width: 320 }),
                    pos(width() / 2 - 160, height() / 2 - 20),
                    color(150, 255, 150),
                    z(101),
                ]);

                const hobbyText = add([
                    text(`Hobby: ${profile.hobby}`, { size: 12, width: 320 }),
                    pos(width() / 2 - 160, height() / 2 + 10),
                    color(180, 180, 255),
                    z(101),
                ]);

                const boostText = add([
                    text(`Series A Boost: ${char.boost}%`, { size: 14 }),
                    pos(width() / 2, height() / 2 + 40),
                    anchor("center"),
                    color(100, 255, 100),
                    z(101),
                ]);

                const closeText = add([
                    text("Click anywhere to close", { size: 10 }),
                    pos(width() / 2, height() / 2 + 70),
                    anchor("center"),
                    color(150, 150, 150),
                    z(101),
                ]);

                profileDisplay = [profileBg, headerText, funFactText, superpowerText, quoteText, hobbyText, boostText, closeText];
            }

            function hideProfile() {
                if (profileDisplay) {
                    profileDisplay.forEach(element => element.destroy());
                    profileDisplay = null;
                    currentProfile = null;
                }
            }

            // Click handler
            onMousePress(() => {
                const mPos = mousePos();
                
                // If profile is showing, hide it on any click
                if (currentProfile) {
                    hideProfile();
                    return;
                }
                
                charObjects.forEach(charCircle => {
                    if (charCircle.cooldown) return;
                    
                    const dist = charCircle.pos.dist(mPos);
                    if (dist < 40) {
                        console.log("Clicked:", charCircle.charData.name);
                        showProfile(charCircle.charData);
                        handleClick(charCircle);
                    }
                });
            });

            function handleClick(charCircle) {
                const char = charCircle.charData;
                let boost = char.boost;

                // Trigger connection ripple effect
                triggerConnectionRipple(char.name);

                // Track if this character is being explored for the first time
                if (!char.explored) {
                    char.explored = true;
                    exploredCount++;
                    explorationText.text = `Team Members Explored: ${exploredCount}/${totalMembers}`;
                    
                    // Add visual indicator for explored character
                    add([
                        text("âœ“", { size: 20 }),
                        pos(char.pos[0] + 35, char.pos[1] - 35),
                        anchor("center"),
                        color(100, 255, 100),
                        { permanent: true }
                    ]);
                }

                if (char.name === "Arianne") {
                    char.growth++;
                    boost = char.boost + char.growth;
                    charCircle.radius = 40 + (char.growth * 2);
                }

                if (char.name === "Maksym") {
                    nextBoosted = true;
                } else if (nextBoosted) {
                    boost = Math.round(boost * 1.2);
                    nextBoosted = false;
                }

                if (char.name === "Thong" && Math.random() > 0.5) {
                    add([
                        text("Real!", { size: 14 }),
                        pos(char.pos[0], char.pos[1] + 100),
                        anchor("center"),
                        color(150, 255, 100),
                        lifespan(1.5),
                    ]);
                }

                add([
                    text(`+${boost}%`, { size: 16 }),
                    pos(char.pos[0] + 50, char.pos[1] - 50),
                    anchor("center"),
                    color(100, 255, 100),
                    lifespan(1),
                ]);

                progressBar.progress += boost;
                if (progressBar.progress > 100) progressBar.progress = 100;
                progressBar.width = (progressBar.progress / 100) * 396;
                progressText.text = `Series A Progress: ${Math.floor(progressBar.progress)}%`;

                // Modified win condition: require both 100% progress AND all team members explored
                if (progressBar.progress >= 100 && exploredCount >= totalMembers) {
                    wait(0.5, () => go("victory"));
                } else if (progressBar.progress >= 100 && exploredCount < totalMembers) {
                    // Show message if progress is 100% but not all members explored
                    add([
                        text("Explore all team members to secure Series A!", { size: 16 }),
                        pos(width() / 2, 200),
                        anchor("center"),
                        color(255, 100, 100),
                        lifespan(3),
                    ]);
                }

                charCircle.cooldown = true;
                wait(1.5, () => {
                    charCircle.cooldown = false;
                });
            }

            onUpdate(() => {
                connectionTime += dt();
                
                // Periodic connection pulses - show random connections every few seconds
                if (connectionTime > 3 && connections.length === 0 && !currentProfile) {
                    connectionTime = 0;
                    
                    // Pick a random character and show their connections briefly
                    const randomChar = characters[Math.floor(Math.random() * characters.length)];
                    showCharacterConnections(randomChar.name, 0.4);
                    
                    // Clear connections after 1.5 seconds
                    wait(1.5, () => {
                        clearConnections();
                    });
                }
                
                const mPos = mousePos();
                charObjects.forEach(charCircle => {
                    const dist = charCircle.pos.dist(mPos);
                    if (dist < 40 && !charCircle.cooldown) {
                        charCircle.scale = vec2(1.1, 1.1);
                        
                        // Show subtle connection hints on hover
                        if (connections.length === 0 && !currentProfile) {
                            const char = charCircle.charData;
                            if (char.connections && char.connections.length > 0) {
                                // Show very faint connections on hover
                                char.connections.forEach(connectedName => {
                                    const connectedChar = characterMap[connectedName];
                                    if (connectedChar) {
                                        const connectionKey = [char.name, connectedName].sort().join('-');
                                        if (!activeConnections.has(connectionKey)) {
                                            const connection = drawConnection(char, connectedChar, 0.15);
                                            connections.push(connection);
                                            activeConnections.add(connectionKey);
                                        }
                                    }
                                });
                            }
                        }
                    } else if (!charCircle.cooldown) {
                        charCircle.scale = vec2(1, 1);
                        
                        // Clear hover connections when mouse moves away
                        if (connections.length > 0 && connections[0].baseIntensity === 0.15) {
                            clearConnections();
                        }
                    }
                });
            });

            add([
                text("Click team members to secure Series A!", { size: 14 }),
                pos(width() / 2, height() - 30),
                anchor("center"),
                color(150, 150, 150),
            ]);
        });

        scene("victory", () => {
            add([
                text("ðŸŽ‰ SERIES A SECURED! ðŸŽ‰", { size: 48 }),
                pos(width() / 2, height() / 2 - 60),
                anchor("center"),
                color(255, 215, 0),
            ]);

            add([
                text("Visual Hive is ready to grow!", { size: 24 }),
                pos(width() / 2, height() / 2),
                anchor("center"),
                color(100, 200, 100),
            ]);

            add([
                text("Click to play again", { size: 16 }),
                pos(width() / 2, height() / 2 + 60),
                anchor("center"),
                color(150, 150, 150),
            ]);

            onClick(() => go("main"));

            for (let i = 0; i < 30; i++) {
                wait(i * 0.05, () => {
                    const c = add([
                        rect(8, 8),
                        pos(rand(0, width()), -20),
                        color(rand(100, 255), rand(100, 255), rand(100, 255)),
                        lifespan(3),
                        { vel: rand(50, 150) }
                    ]);
                    c.onUpdate(() => c.pos.y += c.vel * dt());
                });
            }
        });

        go("main");
    </script>
</body>
</html>
